#' Conditional Method Agreement Trees (COAT)
#'
#' Tree models capturing the dependence of method agreement on covariates.
#' The classic Bland-Altman analysis is used for modeling method agreement
#' while the covariate dependency can be learned either nonparametrically
#' via conditional inference trees (CTree) or using model-based recursive
#' partitioning (MOB).
#'
#' @param formula symbolic description of the model of type \code{y ~ x1 + ... + xk}.
#' The left-hand side should specify the measurements (\code{y}) for the Bland-Altman analysis.
#' The right-hand side can specify any number of potential split variables for the tree.
#' @param data,subset,na.action arguments controlling the formula processing
#' via \code{\link[stats]{model.frame}}.
#' @param weights optional numeric vector of weights (case/frequency weights, by default).
#' @param means logical. Should the intra-individual mean values of measurements
#' be included as potential split variable?
#' @param type character string specifying the type of tree to be fit. Either \code{"ctree"} (default) or \code{"mob"}.
#' @param minsize,minbucket integer. The minimum number of observations in a subgroup.
#' Only one of the two arguments should be used (see also below).
#' @param minsplit integer. The minimum number of observations to consider splitting.
#' Must be at least twice the minimal subgroup size (\code{minsplit} or \code{minbucket}).
#' If set to \code{NULL} (the default) it is set to be at least 2.5 times the minimal
#' subgroup size.
#' @param ... further control arguments, either passed to \code{\link[partykit]{ctree_control}}
#' or \code{\link[partykit]{mob_control}}, respectively.
#'
#' @details Conditional method agreement trees (COAT) employ unbiased
#' recursive partitioning in order to detect and model dependency on covariates
#' in the classic Bland-Altman analysis. One of two recursive partitioning techniques
#' can be used to find subgroups defined by splits in covariates to a pair
#' of measurements, either nonparametric conditional inference trees (CTree)
#' or parametric model-based trees (MOB). In both cases, each subgroup is associated
#' with two parameter estimates: the mean of the measurement difference (\dQuote{Bias})
#' and the corresponding sample standard deviation (\dQuote{SD}) which can be
#' used to construct the limits of agreement (i.e., the corresponding confidence intervals).
#'
#' The minimum number of observations in a subgroup defaults to 10,
#' so that the mean and variance of the measurement differences can be estimated
#' reasonably for the Bland-Altman analysis. The default can be changed with
#' with the argument \code{minsize} or, equivalently, \code{minbucket}.
#' (The different names stem from slightly different conventions in the underlying
#' tree functions.) Consequently, the minimum number of observations to consider
#' splitting (\code{minsplit}) must be, at the very least, twice the minimum number
#' of observations per subgroup (which would allow only one possible split, though).
#' By default, \code{minsplit} is 2.5 times \code{minsize}.
#' Users are encouraged to consider whether for their application it is sensible
#' to increase or decrease these defaults. Finally, further control parameters
#' can be specified through the \code{...} argument, see
#' \code{\link[partykit]{ctree_control}} and \code{\link[partykit]{mob_control}},
#' respectively, for details.
#'
#'
#' To add the means of the measurement pair as a potential splitting variable,
#' there are also different equivalent strategies. The standard specification would
#' be via the \code{means} argument: \code{y ~ x1 + ..., means = TRUE}.
#' Alternatively, the user can also extend the formula argument via
#' \code{y ~ x1 + ... + means(y1, y2)}.
#'
#' The SD is estimated by the usual sample standard deviation in each subgroup,
#' i.e., divided by the sample size \eqn{n - 1}. Note that the inference in the
#' MOB algorithm internally uses the maximum likelihood estimate (divided by \eqn{n})
#' instead so the the fluctuation tests for parameter instability can be applied.
#'
#' @references Karapetyan S, Zeileis A, Henriksen A, Hapfelmeier A (2023).
#' \dQuote{Tree Models for Assessing Covariate-Dependent Method Agreement.}
#' arXiv 2306.04456, \emph{arXiv.org E-Print Archive}.
#' \doi{10.48550/arXiv.2306.04456}
#'
#' @examples
#' \dontshow{ if(!requireNamespace("MethComp")) {
#'   if(interactive() || is.na(Sys.getenv("_R_CHECK_PACKAGE_NAME_", NA))) {
#'     stop("the MethComp package is required for this example but is not installed")
#'   } else q() }
#' }
#' ## package and data
#' library("coat")
#' data("scint", package = "MethComp")
#'
#' ## coat based on ctree() without and with mean values of paired measurements as predictor
#' tr1 <- coat(y ~ age + sex, data = scint)
#'
#' ## display
#' print(tr1)
#' plot(tr1)
#' 
#' ## tweak various graphical arguments of the panel function (just for illustration):
#' ## different colors, nonparametric bootstrap percentile confidence intervals, ...
#' plot(tr1, tp_args = list(
#'   xscale = c(0, 150), linecol = "deeppink",
#'   confint = TRUE, B = 250, cilevel = 0.5, cicol = "gold"
#' ))
#' @return Object of class \code{coat}, inheriting either from \code{constparty} (if \code{\link[partykit]{ctree}}
#' is used) or \code{modelparty} (if \code{\link[partykit]{mob}} is used).
#'
#' @importFrom stats model.weights na.omit update weighted.mean
#' @importFrom partykit ctree_control mob_control
#'
#' @export
coat.fit <- function(formula, data, subset, na.action, weights, means = FALSE, type = c("ctree", "mob"),
                     replicates = FALSE, paired = FALSE, minsize = 10L, alpha = 0.05, minbucket = minsize, minsplit = NULL, ...){
  
  ## set replicates with paired measurements
  if(paired) replicates <- TRUE
  
  ## type of tree
  type <- match.arg(tolower(type), c("ctree", "mob"))
  if (replicates & type != "ctree") {
    type <- "ctree"
    warning("'type' was set to 'ctree' with replicate measurements")
  }
  
  ## keep call
  cl <- match.call(expand.dots = TRUE)
  
  ## preparation of ctree/mob call
  m <- match.call(expand.dots = FALSE)
  if(missing(na.action)) m$na.action <- na.omit
  
  ## update formula
  if (replicates) {
    if (!paired) {
      formula <- as.formula(paste("`_mean_diff_` ~", paste(c("id", "nr1", "nr2", "rss1", "rss2", "`_means_`"), collapse = "+"), "|", formula[3], ifelse(means, "+ `_means_`", "")))
    } else {
      formula <- as.formula(paste("`_mean_diff_` ~", paste(c("id", "nr", "rss", "`_means_`"), collapse = "+"), "|", formula[3], ifelse(means, "+ `_means_`", "")))
    }
  } else {
    formula <- as.formula(paste("`_diff_` ~ id + `_means_`|", formula[3], ifelse(means, "+ `_means_`", "")))
  }
  m$formula <- formula
  
  # ## if desired "means(y1, y2)" is added as split variable
  # if(means) {
  #  formula <- update(formula, . ~ . + `_means_`)
  #  m$formula <- formula
  # }
  
  ## update/remove processed arguments
  m$means <- NULL
  m$type <- NULL
  
  ## process hyperparameters
  if(!missing(minsize) && !missing(minbucket)) {
    warning("the minimal subgroup size should either be specified by 'minsize' or 'minbucket' but not both, using 'minsize'")
    minbucket <- minsize
  }
  minsize <- minbucket
  if(is.null(minsplit)) minsplit <- ceiling(2.5 * minsize)
  if(minsplit < 2L * minsize) {
    warning("the minimal sample size to consider splitting ('minsplit') must be at least twice the minimal subgroup size ('minsize'), increased accordingly")
    minsplit <- 2L * minsize
  }
  
  ## add trafo function for ctree
  m[[1L]] <- as.call(quote(partykit::ctree))
  if(replicates) {
    if(paired) {m$ytrafo <- batrafo.repl.pair
    } else m$ytrafo <- batrafo.repl.unpair
  }  else m$ytrafo <- batrafo
  m$control <- partykit::ctree_control(minbucket = minsize, minsplit = minsplit, alpha = alpha, ...)
  
  ## add fit function for mob
  if(type == "mob") {
    m[[1L]] <- as.call(quote(partykit::mob))
    m$fit <- bafit
    m$control <- partykit::mob_control(minsize = minsize, minsplit = minsplit, alpha = alpha, ...)
    m$control$ytype <- "matrix"
  }
  
  ## fit tree
  rval <- eval(m, parent.frame())
  
  ## informative warning whether tree considered splitting at all
  if(is.null(rval$node$split) && (is.null(rval$node$info) || is.null(rval$node$info$test))) {
    message("Info: The tree has no splits due to the hyperparameters ('minsize', 'minsplit', ...), no test were carried out, possibly consider adjusting the hyperparameters.")
  }
  
  if(is.null(rval)){message("we did not get there")}
  
  ## unify output
  rval$info$call <- cl
  class(rval) <- c("coat", class(rval))
  
  # for the further functions we add an additional class paired/unpaired
  if(replicates) {
    if(paired) {class(rval) <- c(class(rval), "paired")
    } else class(rval) <- c(class(rval), "unpaired")
  }
  
  return(rval)
}

coat <- function(formula, data, id = NULL, meth = NULL, subset, na.action, weights, means = FALSE, type = c("ctree", "mob"),
                 replicates = FALSE, paired = FALSE, minsize = 10L, alpha = 0.05, minbucket = minsize, minsplit = NULL, ...){
  cl <- match.call()
  
  if(replicates & (is.null(id) | is.null(meth))) stop("arguments id or meth are missing")
  
  data <- coat.reshape(formula, data, id = id, meth = meth, replicates = replicates, paired = paired)
  fit <- coat.fit(formula, data, replicates = replicates, paired = paired, type = type, means = means, na.action = na.action,
                  minsize = minsize, minsplit = minsplit, alpha = alpha, ...)
  
  fit$info$call <- cl
  return(fit)
}
